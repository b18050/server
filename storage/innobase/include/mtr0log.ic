/*****************************************************************************

Copyright (c) 1995, 2016, Oracle and/or its affiliates. All Rights Reserved.
Copyright (c) 2017, 2020, MariaDB Corporation.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA

*****************************************************************************/

/**************************************************//**
@file include/mtr0log.ic
Mini-transaction logging routines

Created 12/7/1995 Heikki Tuuri
*******************************************************/

#include "buf0dblwr.h"
#include "fsp0types.h"
#include "mach0data.h"
#include "trx0types.h"

/********************************************************//**
Opens a buffer to mlog. It must be closed with mlog_close.
@return buffer, NULL if log mode MTR_LOG_NONE or MTR_LOG_NO_REDO */
UNIV_INLINE
byte*
mlog_open(
/*======*/
	mtr_t*	mtr,	/*!< in: mtr */
	ulint	size)	/*!< in: buffer size in bytes; MUST be
			smaller than mtr_t::buf_t::MAX_DATA_SIZE! */
{
	mtr->set_modified();

	if (mtr_get_log_mode(mtr) == MTR_LOG_NONE
	    || mtr_get_log_mode(mtr) == MTR_LOG_NO_REDO) {

		return(NULL);
	}

	return(mtr->get_log()->open(size));
}

/********************************************************//**
Closes a buffer opened to mlog. */
UNIV_INLINE
void
mlog_close(
/*=======*/
	mtr_t*	mtr,	/*!< in: mtr */
	byte*	ptr)	/*!< in: buffer space from ptr up was not used */
{
	ut_ad(mtr_get_log_mode(mtr) != MTR_LOG_NONE);
	ut_ad(mtr_get_log_mode(mtr) != MTR_LOG_NO_REDO);

	mtr->get_log()->close(ptr);
}

/********************************************************//**
Catenates 1 - 4 bytes to the mtr log. The value is not compressed. */
UNIV_INLINE
void
mlog_catenate_ulint(
/*================*/
	mtr_buf_t*	mtr_buf,	/*!< in/out: buffer to write */
	ulint		val,		/*!< in: value to write */
	mlog_id_t	type)		/*!< in: type of value to write */
{
	compile_time_assert(MLOG_1BYTE == 1);
	compile_time_assert(MLOG_2BYTES == 2);
	compile_time_assert(MLOG_4BYTES == 4);
	compile_time_assert(MLOG_8BYTES == 8);

	byte*	ptr = mtr_buf->push<byte*>(type);

	switch (type) {
	case MLOG_4BYTES:
		mach_write_to_4(ptr, val);
		break;
	case MLOG_2BYTES:
		mach_write_to_2(ptr, val);
		break;
	case MLOG_1BYTE:
		mach_write_to_1(ptr, val);
		break;
	default:
		ut_error;
	}
}

/********************************************************//**
Catenates 1 - 4 bytes to the mtr log. The value is not compressed. */
UNIV_INLINE
void
mlog_catenate_ulint(
/*================*/
	mtr_t*		mtr,	/*!< in/out: mtr */
	ulint		val,	/*!< in: value to write */
	mlog_id_t	type)	/*!< in: MLOG_1BYTE, MLOG_2BYTES, MLOG_4BYTES */
{
	if (mtr_get_log_mode(mtr) == MTR_LOG_NONE
	    || mtr_get_log_mode(mtr) == MTR_LOG_NO_REDO) {

		return;
	}

	mlog_catenate_ulint(mtr->get_log(), val, type);
}

/** Writes a log record about an operation.
@param[in]	type		redo log record type
@param[in]	space_id	tablespace identifier
@param[in]	page_no		page number
@param[in,out]	log_ptr		current end of mini-transaction log
@param[in,out]	mtr		mini-transaction
@return	end of mini-transaction log */
UNIV_INLINE
byte*
mlog_write_initial_log_record_low(
	mlog_id_t	type,
	ulint		space_id,
	ulint		page_no,
	byte*		log_ptr,
	mtr_t*		mtr)
{
	ut_ad(type <= MLOG_BIGGEST_TYPE);
	ut_ad(type == MLOG_FILE_NAME
	      || type == MLOG_FILE_DELETE
	      || type == MLOG_FILE_CREATE2
	      || type == MLOG_FILE_RENAME2
	      || mtr->is_named_space(space_id));

	mach_write_to_1(log_ptr, type);
	log_ptr++;

	log_ptr += mach_write_compressed(log_ptr, space_id);
	log_ptr += mach_write_compressed(log_ptr, page_no);

	mtr->added_rec();
	return(log_ptr);
}
